// =============================================================================
// PHASE 1 — FOUNDATIONS
// =============================================================================
// Computer Science primitives, cryptographic building blocks, consensus theory,
// and blockchain architectural patterns (monolithic vs modular, L1/L2/DA).
//
// ADD HERE: new consensus mechanisms, cryptographic primitives, scaling concepts,
// or high-level architectural groupings.
// =============================================================================

import { CryptoNodeData } from '../types';

export const foundationNodes: CryptoNodeData[] = [
  // ── ROOT ────────────────────────────────────────────────────────────────────
  {
    id: 'root',
    parentId: null,
    label: 'Computer Science Foundations',
    description: 'Core CS concepts that underpin all blockchain systems',
    category: 'core',
    dependencies: [],
    shortOverview: 'The fundamental theories and technologies from computer science that enable blockchain technology to exist.',
    deepInsight: 'Blockchain is inherently interdisciplinary, improving upon decades of research in cryptography, distributed computing, and game theory. To understand how a blockchain functions without a central authority, one must grasp how these foundational elements interact: cryptographic primitives ensure data integrity and ownership, distributed systems principles maintain consistency across a network of untrusted nodes, and mechanism design aligns economic incentives.',
  },

  // ── CRYPTOGRAPHY ────────────────────────────────────────────────────────────
  {
    id: 'cryptography',
    parentId: 'root',
    label: 'Cryptography',
    description: 'Mathematical primitives for securing and verifying blockchain data',
    category: 'core',
    dependencies: ['root'],
    shortOverview: 'The practice of secure communication in the presence of adversarial behavior.',
    deepInsight: 'In blockchain, cryptography is not used for confidentiality (encrypting data so others can\'t see it), but for authentication and integrity. It allows anyone to verify that a transaction was signed by the owner of the funds (Digital Signatures) and that the history of transactions has not been tampered with (Hash Functions).',
  },
  {
    id: 'hash-functions',
    parentId: 'cryptography',
    label: 'Hash Functions',
    description: 'One-way functions (SHA-256, Keccak) used for content addressing and mining',
    category: 'core',
    dependencies: ['cryptography'],
    shortOverview: 'Mathematical algorithms that map data of arbitrary size to a fixed-size string, acting as a digital fingerprint.',
    deepInsight: 'Cryptographic hash functions like SHA-256 have key properties: Deterministic (same input = same output), Fast to compute, Pre-image resistance (hard to find input from output), and Avalanche effect (small change in input = huge change in output). They are used in Merkle Trees to summarize block data efficiently and in Proof of Work mining to create cryptographic puzzles.',
  },
  {
    id: 'public-key-crypto',
    parentId: 'cryptography',
    label: 'Public Key Cryptography',
    description: 'Asymmetric encryption (ECDSA, EdDSA) enabling wallet ownership and signatures',
    category: 'core',
    dependencies: ['cryptography'],
    shortOverview: 'A cryptographic system that uses pairs of keys: public keys which may be disseminated widely, and private keys which are known only to the owner.',
    deepInsight: 'This is the basis of "ownership" in crypto. Your public key is your address (like a mailbox), derived from your private key. Your private key can sign messages (transactions). The network uses your public key to mathematically verify that the signature was generated by the corresponding private key, without ever revealing the private key itself. Elliptic Curve Cryptography (ECC) is the standard used in Bitcoin and Ethereum.',
  },
  {
    id: 'merkle-trees',
    parentId: 'cryptography',
    label: 'Merkle Trees',
    description: 'Hash tree structures for efficient state verification and light clients',
    category: 'core',
    dependencies: ['cryptography'],
    shortOverview: 'A tree structure where every leaf node is a hash of a data block, and every non-leaf node is a hash of its children.',
    deepInsight: 'Merkle Trees allow for efficient and secure verification of large data structures. Instead of downloading an entire blockchain to check if a specific transaction exists in a block, a "light client" only needs the Merkle Root (the top hash) and a specific "Merkle Path". If the path hashes up to the root, the transaction is proven to be part of the block. This is essential for scalability.',
  },
  {
    id: 'zk-cryptography',
    parentId: 'cryptography',
    label: 'Zero-Knowledge Proofs',
    description: 'Cryptographic protocols (SNARKs, STARKs) for proving computation without revealing data',
    category: 'core',
    dependencies: ['cryptography'],
    shortOverview: 'A method by which one party (the prover) can prove to another party (the verifier) that they know a value x, without conveying any information apart from the fact that they know the value x.',
    deepInsight: 'ZK proofs are revolutionary for blockchain scalability and privacy. ZK-Rollups use them to bundle thousands of transactions off-chain and generate a tiny proof that attests to their validity. The main chain verifies this proof in constant time, inheriting the security of the main chain without doing the heavy lifting of processing every transaction.',
  },

  // ── DISTRIBUTED SYSTEMS ─────────────────────────────────────────────────────
  {
    id: 'distributed-systems',
    parentId: 'root',
    label: 'Distributed Systems',
    description: 'Network architectures and state management across untrusted nodes',
    category: 'core',
    dependencies: ['root'],
    shortOverview: 'A field of CS that studies systems whose components are located on different networked computers, which communicate and coordinate their actions by passing messages.',
    deepInsight: 'Blockchains are messy distributed systems. They face the CAP theorem (Consistency, Availability, Partition Tolerance). Unlike a centralized database where one server is the source of truth, a blockchain must ensure all nodes eventually agree on the state (Consistency) even if some nodes fail or are malicious, and even if messages are delayed.',
  },
  {
    id: 'p2p-networks',
    parentId: 'distributed-systems',
    label: 'Peer-to-Peer Networks',
    description: 'Decentralized network topology with gossip protocols for transaction propagation',
    category: 'core',
    dependencies: ['distributed-systems'],
    shortOverview: 'A distributed application architecture that partitions tasks or workloads between peers. Peers are equally privileged, equipotent participants in the application.',
    deepInsight: 'In a blockchain P2P network, there is no central server. Nodes connect to a subset of other nodes. When a user broadcasts a transaction, it uses a "Gossip Protocol" to propagate: Node A tells Node B, B tells C and D, and so on. This ensures censorship resistance—there is no single point of failure or control to shut down.',
  },
  {
    id: 'state-machines',
    parentId: 'distributed-systems',
    label: 'State Machines',
    description: 'Deterministic transition functions mapping transactions to new blockchain states',
    category: 'core',
    dependencies: ['distributed-systems'],
    shortOverview: 'A mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time.',
    deepInsight: 'A blockchain is a Replicated State Machine. The "Genesis Block" is the initial state. A block of transactions is a "State Transition". If every node starts at the same Genesis State and applies the exact same blocks in the exact same order (using a deterministic function like the EVM), they will all arrive at the exact same current state. Consensus is just agreeing on the order of transitions.',
  },
  {
    id: 'consensus-mechanisms',
    parentId: 'distributed-systems',
    label: 'Consensus Mechanisms',
    description: 'Protocols for achieving agreement on transaction ordering in adversarial environments',
    category: 'core',
    dependencies: ['distributed-systems'],
    shortOverview: 'Fault-tolerant mechanisms used in computer and blockchain systems to achieve the necessary agreement on a single data value or a single state of the network.',
    deepInsight: 'The "Byzantine Generals Problem" describes the challenge of reaching consensus when some participants may be traitors. Consensus mechanisms solve this. They define: 1) Who gets to propose the next block? (Leader Election) 2) How do we know it\'s valid? (Verification) 3) What happens if there are two competing blocks? (Fork Choice Rule).',
  },
  {
    id: 'pow',
    parentId: 'consensus-mechanisms',
    label: 'Proof of Work (PoW)',
    description: 'Nakamoto consensus using computational puzzles for Sybil resistance',
    category: 'core',
    dependencies: ['consensus-mechanisms'],
    shortOverview: 'A consensus algorithm that requires a participant to expend effort to solve an arbitrary mathematical puzzle to prevent frivolous or malicious uses of computing power.',
    deepInsight: 'Sybil Resistance via Energy. To propose a block, you must prove you spent real-world resources (electricity/hardware). This makes it prohibitively expensive to attack the network (51% attack). It prioritizes liveness and openness (anyone can mine) but suffers from high energy consumption and slower finality.',
  },
  {
    id: 'pos',
    parentId: 'consensus-mechanisms',
    label: 'Proof of Stake (PoS)',
    description: 'Economic security through staked capital and slashing conditions',
    category: 'core',
    dependencies: ['consensus-mechanisms'],
    shortOverview: 'A consensus algorithm where block validators are chosen to create a new block based on the number of coins they hold and are willing to "stake" as collateral.',
    deepInsight: 'Sybil Resistance via Capital. Instead of burning energy, you lock up tokens. If you act maliciously (e.g., voting on two conflicting blocks), your stake is "slashed" (destroyed). PoS allows for faster finality and vastly lower energy usage compared to PoW, but introduces different centralization risks.',
  },
  {
    id: 'bft',
    parentId: 'consensus-mechanisms',
    label: 'Byzantine Fault Tolerance',
    description: 'Classical consensus (PBFT, Tendermint) with finality guarantees',
    category: 'core',
    dependencies: ['consensus-mechanisms'],
    shortOverview: 'The property of a system that is able to resist the class of failures derived from the Byzantine Generals Problem.',
    deepInsight: 'BFT algorithms (like PBFT or Tendermint) focus on instant or near-instant finality. Once a block is committed, it cannot be reverted (unlike PoW\'s probabilistic finality). However, they typically scale worse with the number of nodes (communication overhead increases quadratically) compared to Nakamoto Consensus.',
  },

  // ── GAME THEORY ─────────────────────────────────────────────────────────────
  {
    id: 'game-theory',
    parentId: 'root',
    label: 'Game Theory & Mechanism Design',
    description: 'Incentive structures that align self-interested actors with protocol goals',
    category: 'core',
    dependencies: ['root'],
    shortOverview: 'The study of strategic interactions between rational agents — the backbone of tokenomics and protocol design.',
    deepInsight: 'Blockchains run on incentives, not trust. Game theory asks: "Given that every participant acts in their own self-interest, how do we design rules so that selfish behavior produces good outcomes?" Mechanism design is its engineering counterpart. Token emissions, staking yields, slashing penalties, and MEV auctions are all game-theoretic instruments. The Ethereum fee mechanism (EIP-1559) is a textbook example: it burns base fees so miners can\'t manipulate them, and adds a tip to preserve inclusion incentives.',
  },

  // ── BLOCKCHAIN ARCHITECTURE ─────────────────────────────────────────────────
  {
    id: 'blockchain-architecture',
    parentId: 'root',
    label: 'Blockchain Architecture',
    description: 'Structural design patterns for scaling and modularity',
    category: 'chain-group',
    dependencies: ['root'],
    shortOverview: 'The high-level design choices that define how a blockchain processes transactions and reaches consensus.',
    deepInsight: 'The key challenge in architecture is the "Blockchain Trilemma": it\'s hard to achieve Scalability, Security, and Decentralization simultaneously. Monolithic chains try to balance all three in one layer. Modular architectures break them apart, optimizing different layers for different purposes (e.g., Execution vs. Settlement).',
  },
  {
    id: 'monolithic',
    parentId: 'blockchain-architecture',
    label: 'Monolithic Chains',
    description: 'Single-layer architectures handling execution, consensus, and data availability together',
    category: 'chain-group',
    dependencies: ['blockchain-architecture'],
    shortOverview: 'A blockchain where execution, settlement, consensus, and data availability are all handled by the same set of nodes.',
    deepInsight: 'Bitcoin, Solana, and early Ethereum are monolithic. Every node must process every transaction. This is simple and secure but hard to scale: to process more transactions, you need bigger computers (vertical scaling), which reduces decentralization because fewer people can run nodes.',
  },
  {
    id: 'modular',
    parentId: 'blockchain-architecture',
    label: 'Modular Chains',
    description: 'Separation of execution, consensus, and DA into specialized layers',
    category: 'chain-group',
    dependencies: ['blockchain-architecture'],
    shortOverview: 'A design paradigm that splits the core functions of a blockchain into separate, specialized layers.',
    deepInsight: 'Instead of one chain doing everything, we might have a fast Rollup (Layer 2) for Execution (processing transactions), Ethereum (Layer 1) for Settlement (security/bridging), and Celestia for Data Availability (storing transaction data). This allows each layer to optimize for its specific job, theoretically enabling infinite scalability.',
  },
  {
    id: 'layer1',
    parentId: 'modular',
    label: 'Layer 1 (Settlement)',
    description: 'Base layer providing security and final settlement guarantees for rollups',
    category: 'chain-group',
    dependencies: ['modular'],
    shortOverview: 'The foundational blockchain (like Ethereum) that serves as the ultimate source of truth and security for rollup ecosystems.',
    deepInsight: 'Layer 1 is where disputes are resolved and funds are secured. For modular stacks (like Rollups), the L1 is the "Settlement Layer". It verifies proofs from L2s and allows users to withdraw their funds even if the L2 goes down or acts maliciously. Ethereum is the dominant L1 settlement layer.',
  },
  {
    id: 'layer2',
    parentId: 'modular',
    label: 'Layer 2 (Execution)',
    description: 'Off-chain execution layers that inherit L1 security through proofs or fraud detection',
    category: 'chain-group',
    dependencies: ['modular'],
    shortOverview: 'Secondary frameworks built on top of an existing blockchain (L1) to increase transaction speed and reduce costs.',
    deepInsight: 'L2s move computation off-chain. They process thousands of transactions effectively locally, then submit a compressed summary to the L1. They inherit the security of the L1 because the L1 contract checks the validity of the summary (via ZK Proofs or Fraud Proofs).',
  },
  {
    id: 'optimistic-rollups',
    parentId: 'layer2',
    label: 'Optimistic Rollups',
    description: 'L2s assuming valid execution with fraud proof challenge periods (7-day withdrawal)',
    category: 'chain-group',
    dependencies: ['layer2'],
    shortOverview: 'A type of Layer 2 that assumes transactions are valid by default and only runs computation if someone challenges them ("Innocent until proven guilty").',
    deepInsight: 'They publish transaction data to L1 but don\'t execute it there. A "challenge period" (usually 7 days) allows anyone to submit a "Fraud Proof" if they see an invalid transaction. If no challenge happens, the state is finalized. This is simpler to build but requires a waiting period for withdrawals.',
  },
  {
    id: 'zk-rollups',
    parentId: 'layer2',
    label: 'ZK Rollups',
    description: 'L2s using validity proofs for instant finality and cryptographic execution guarantees',
    category: 'chain-group',
    dependencies: ['layer2'],
    shortOverview: 'A Layer 2 that uses zero-knowledge proofs to mathematically verify the correctness of off-chain transactions on the L1.',
    deepInsight: 'Every batch of transactions submitted to L1 comes with a "Validity Proof" (SNARK or STARK). The L1 verifies this proof, which guarantees that all transactions in the batch are valid. This offers instant finality (no 7-day wait) and higher security, but is much harder to engineer.',
  },
  {
    id: 'da-layer-concept',
    parentId: 'modular',
    label: 'Data Availability Layer',
    description: 'Specialized networks ensuring transaction data is published and retrievable',
    category: 'chain-group',
    dependencies: ['modular'],
    shortOverview: 'A blockchain layer dedicated solely to storing and guaranteeing the availability of transaction data.',
    deepInsight: 'For Rollups to be secure, the data needed to reconstruct the state (Data Availability) must be public. If a sequencer hides data, no one can create a fraud proof or a ZK proof. DA layers (like Celestia) focus purely on ordering and storing this data cheaply, without executing it.',
  },
  {
    id: 'l3-appchains',
    parentId: 'layer2',
    label: 'L3s / App-Chains',
    description: 'Application-specific chains built on top of L2s for maximal throughput and custom rules',
    category: 'chain-group',
    dependencies: ['layer2'],
    shortOverview: 'Chains that settle to an L2 (instead of L1 directly), enabling ultra-cheap transactions for a single application.',
    deepInsight: 'App-chains take modularity to its extreme: a single game, exchange, or social app runs on its own blockchain. They settle to an L2 like Arbitrum or Optimism, inheriting Ethereum security two hops away. Frameworks like Arbitrum Orbit and OP Stack make deploying an app-chain a matter of days. The tradeoff is liquidity fragmentation — each app-chain needs bridges and UX glue to connect to the broader ecosystem.',
  },
];
